/*******************************************************************************
 * Caleydo - visualization for molecular biology - http://caleydo.org
 *
 * Copyright(C) 2005, 2012 Graz University of Technology, Marc Streit, Alexander
 * Lex, Christian Partl, Johannes Kepler University Linz </p>
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>
 *******************************************************************************/
package org.caleydo.core.data.virtualarray.group;

import java.util.ArrayList;
import java.util.Iterator;

import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.bind.annotation.XmlType;

import org.caleydo.core.data.selection.SelectionType;
import org.caleydo.core.data.virtualarray.VirtualArray;
import org.caleydo.core.data.virtualarray.delta.VirtualArrayDelta;

/**
 * A group list provides handling of groups (generated by a cluster algorithm or
 * by user interaction). A group is a bulk of genes or patients.
 *
 * @author Bernhard Schlegl
 * @author Alexander Lex
 */
@XmlType
@XmlSeeAlso({ RecordGroupList.class, DimensionGroupList.class })
public abstract class GroupList<ConcreteType extends GroupList<ConcreteType, VA, VADelta>, VA extends VirtualArray<?, ?, ?>, VADelta extends VirtualArrayDelta<?>>
		implements Iterable<Group>
// implements IGroupList<ConcreteType, VA, VADelta> {
{
	private ArrayList<Group> groups;

	/**
	 * default no-arg constructor to create a group list with no contained
	 * groups
	 */
	public GroupList() {
		this.groups = new ArrayList<Group>();
	}

	public abstract ConcreteType createInstance();

	/**
	 * Inserts the specified element at the specified position in this list.
	 * Shifts the element currently at that position (if any) and any subsequent
	 * elements to the right (adds one to their indices).
	 *
	 * @param iIndex
	 *            the position on which to insert the new element
	 * @param newElement
	 *            the index to the collection
	 */
	public void add(int index, Group newElement) {
		groups.add(index, newElement);
	}

	/**
	 * Adds an element to the end of the list.
	 *
	 * @param iNewElement
	 *            the index to the collection
	 */
	public void append(Group newElement) {
		newElement.setGroupIndex(groups.size());
		groups.add(newElement);
	}

	/**
	 * Adds an element to the end of the list, if the element is not already
	 * contained.
	 *
	 * @param newElement
	 *            the index to the collection
	 * @exception IllegalArgumentException
	 *                if the value of the new element is larger than allowed.
	 *                The maximum allowed value is the length of the collection
	 *                which is managed - 1
	 * @return true if the array was modified, else false
	 */
	public boolean appendUnique(Group newElement) {
		if (indexOf(newElement) != -1)
			return false;

		append(newElement);
		return true;
	}

	/**
	 * Reset the group list to contain no elements
	 */
	public void clear() {
		groups.clear();

	}

	/**
	 * Checks whether an element is contained in the group list.
	 *
	 * @param element
	 *            the element to be checked
	 * @return true or false
	 */
	public boolean containsElement(Group element) {
		for (Group compareElement : groups) {
			if (compareElement == element) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Copies the element at index iIndex to the next index. Shifts the element
	 * currently at that position (if any) and any subsequent elements to the
	 * right (adds one to their indices).
	 *
	 * @param iIndex
	 *            the index of the element to be copied
	 */
	public void copy(int index) {
		groups.add(index + 1, groups.get(index));

	}

	/**
	 * Returns the group with the specified ID (also the index in the group
	 * list)
	 *
	 * @param groupIndex
	 *            the id of the group the index
	 * @return the group with the id, at that index
	 */
	public Group get(int groupIndex) {
		return groups.get(groupIndex);
	}

	/**
	 * Returns the index of the specified element in this list, or -1 if this
	 * list does not contain the element.
	 *
	 * @param element
	 *            element to search for
	 * @return the index of the the specified element in this list, or -1 if
	 *         this list does not contain the element
	 */
	public int indexOf(Group group) {
		return groups.indexOf(group);
	}

	/**
	 * Returns an Iterator<Group> of type GroupIterator, which allows to iterate
	 * over the group list
	 */
	@Override
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public GroupIterator<ConcreteType> iterator() {
		return new GroupIterator(this);
	}

	// @Override
	// public void move(int srcIndex, int targetIndex) {
	// Group element = iAlGroup.remove(srcIndex);
	// iAlGroup.add(targetIndex, element);
	//
	// System.out.println("Reordering of indexes in the corresponding VA not implemented yet!");
	// }
	//
	// @Override
	// public void moveLeft(int index) {
	// if (index == 0)
	// return;
	// Group temp = iAlGroup.get(index - 1);
	// iAlGroup.set(index - 1, iAlGroup.get(index));
	// iAlGroup.set(index, temp);
	//
	// System.out.println("Reordering of indexes in the corresponding VA not implemented yet!");
	// }
	//
	// @Override
	// public void moveRight(int index) {
	// if (index == size() - 1)
	// return;
	// Group temp = iAlGroup.get(index + 1);
	// iAlGroup.set(index + 1, iAlGroup.get(index));
	// iAlGroup.set(index, temp);
	//
	// System.out.println("Reordering of indexes in the corresponding VA not implemented yet!");
	// }

	/**
	 * Removes the element at the specified index. Shifts any subsequent
	 * elements to the left (subtracts one from their indices).
	 *
	 * @param iIndex
	 *            the index of the element to be removed
	 * @return the Element that was removed from the list
	 */
	public Group remove(int index) {
		return groups.remove(index);
	}

	/**
	 * <p>
	 * Remove an element from the list. Shifts any subsequent elements to the
	 * left (subtracts one from their indices).
	 * </p>
	 * <p>
	 * Notice that this has a complexity of O(n) TODO: probably add a higher
	 * performance version, with an additional hash map
	 * </p>
	 *
	 * @param element
	 *            the element to be removed
	 */
	public void removeByElement(Group element) {
		Iterator<Group> iter = groups.iterator();
		while (iter.hasNext()) {
			if (iter.next() == element) {
				iter.remove();
			}
		}
	}

	/**
	 * Initialize group list
	 */
	private void init() {
		// Group initialGroup = new Group(iAlVirtualArray.size());
		Group initialGroup = new Group();
		this.groups = new ArrayList<Group>();
		groups.add(initialGroup);
	}

	/**
	 * Reset the group list to the indices in the managed data entity
	 */
	public void reset() {
		init();
	}

	/**
	 * Replaces the element at the specified position in this list with the
	 * specified element.
	 *
	 * @param iIndex
	 * @param newElement
	 */
	public void set(int index, Group newElement) {
		groups.set(index, newElement);
	}

	/**
	 * Applies the operations specified in the delta to the group list
	 *
	 * @param delta
	 */
	public void setDelta(VADelta delta) {
		try {
			throw new Exception("Not implemented yet!");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Returns the size of the group list
	 *
	 * @return the size
	 */
	public Integer size() {
		return groups.size();
	}

	/**
	 * Interchanges two elements in the list. Returns true if operation executed
	 * correctly and false otherwise
	 *
	 * @param virtualArray
	 *            the virtual array for updating indexes
	 * @param iIndex1
	 *            the index of the first element
	 * @param iIndex2
	 *            the index of the second element
	 * @return true if operation executed correctly otherwise false
	 */
	public boolean interchange(VA virtualArray, int index1, int index2) {

		int iFirstIdxG1 = 0;
		int iLastIdxG1 = 0;
		int iFirstIdxG2 = 0;
		int iLastIdxG2 = 0;
		int iNrElemG1 = groups.get(index1).getSize();
		int iNrElemG2 = groups.get(index2).getSize();

		ArrayList<Integer> altemp1 = new ArrayList<Integer>();
		ArrayList<Integer> altemp2 = new ArrayList<Integer>();

		int iCnt = 0;
		for (Group iter : groups) {
			iLastIdxG1 += iter.getSize();

			if (iCnt == index1)
				break;
			iCnt++;
		}
		iFirstIdxG1 = iLastIdxG1 - groups.get(index1).getSize();

		iCnt = 0;
		for (Group iter : groups) {
			iLastIdxG2 += iter.getSize();

			if (iCnt == index2)
				break;
			iCnt++;
		}
		iFirstIdxG2 = iLastIdxG2 - groups.get(index2).getSize();

		for (int i = 0; i < iNrElemG2; i++) {

			altemp2.add(virtualArray.get(iFirstIdxG2));
			virtualArray.remove(iFirstIdxG2);
		}

		for (int i = 0; i < iNrElemG1; i++) {

			altemp1.add(virtualArray.get(iFirstIdxG1));
			virtualArray.remove(iFirstIdxG1);
		}

		for (int i = 0; i < iNrElemG2; i++) {
			virtualArray.add(iFirstIdxG1 + i, altemp2.get(i));
		}

		for (int i = 0; i < iNrElemG1; i++) {
			virtualArray.add(iFirstIdxG2 - iNrElemG1 + iNrElemG2 + i, altemp1.get(i));
		}

		Group temp = groups.get(index1);
		groups.set(index1, groups.get(index2));
		groups.set(index2, temp);
		groups.get(index1).setSelectionType(SelectionType.NORMAL);
		groups.get(index2).setSelectionType(SelectionType.NORMAL);

		return true;
	}

	/**
	 * Merges two elements in the list. This means the second group will be
	 * deleted and the number of elements will be added to the first group. The
	 * selection type, the index of the example, and the status of collapse will
	 * not be changed in the first group. Returns true if operation executed
	 * correctly and false otherwise
	 *
	 * @param virtualArray
	 *            the virtual array for updating indexes
	 * @param iIndex1
	 *            the index of the first element
	 * @param iIndex2
	 *            the index of the second element
	 * @return true if operation executed correctly otherwise false
	 */
	public boolean merge(VA virtualArray, int index1, int index2) {

		// int iFirstIdxG1 = 0;
		int iLastIdxG1 = 0;
		int iFirstIdxG2 = 0;
		int iLastIdxG2 = 0;
		int iNrElemG1 = groups.get(index1).getSize();
		int iNrElemG2 = groups.get(index2).getSize();

		ArrayList<Integer> altemp = new ArrayList<Integer>();

		int iCnt = 0;
		for (Group iter : groups) {
			iLastIdxG1 += iter.getSize();

			if (iCnt == index1)
				break;
			iCnt++;
		}
		// iFirstIdxG1 = iLastIdxG1 - iAlGroup.get(index1).getNrElements();

		iCnt = 0;
		for (Group iter : groups) {
			iLastIdxG2 += iter.getSize();

			if (iCnt == index2)
				break;
			iCnt++;
		}
		iFirstIdxG2 = iLastIdxG2 - groups.get(index2).getSize();

		for (int i = 0; i < iNrElemG2; i++) {

			altemp.add(virtualArray.get(iFirstIdxG2));
			virtualArray.remove(iFirstIdxG2);
		}

		for (int i = 0; i < iNrElemG2; i++) {
			virtualArray.add(iLastIdxG1 + i, altemp.get(i));
		}

		groups.remove(index2);
		groups.get(index1).setSize(iNrElemG1 + iNrElemG2);
		groups.get(index1).setSelectionType(SelectionType.SELECTION);

		return true;
	}

	/**
	 * Splits the element at the specified index into two or three new groups.
	 * The number of generated elements depends on the position of the new group
	 * inside the old one. Returns true if operation executed correctly and
	 * false otherwise. An error occurs when the indexes in the VA exceed the
	 * indexes determined by the group
	 *
	 * @param iIndex
	 *            the index of the element to split
	 * @param iVAIdx1
	 *            the first index of the new group in the VA
	 * @param iVAIdx2
	 *            the last index of the new group in the VA
	 * @return true if operation executed correctly otherwise false
	 */
	public boolean split(int index, int idx1, int idx2) {

		int iFirstIdx = 0;
		int iLastIdx = 0;

		int iCnt = 0;

		if (idx2 < idx1) {
			int temp = idx1;
			idx1 = idx2;
			idx2 = temp;
		}

		for (Group iter : groups) {
			iLastIdx += iter.getSize();

			if (iCnt == index)
				break;
			iCnt++;
		}

		iFirstIdx = iLastIdx - groups.get(index).getSize();

		if (idx1 < iFirstIdx || idx2 > iLastIdx)
			return false;

		// 1 new group
		if (idx1 == iFirstIdx) {

			int iNrElements = idx2 - idx1;
			Group newGroup = new Group(iNrElements);

			groups.get(index).setCollapsed(false);
			groups.get(index).setSelectionType(SelectionType.NORMAL);
			groups.get(index).setSize(groups.get(index).getSize() - iNrElements);
			groups.add(index, newGroup);

			return true;
		}

		// 1 new group
		if (idx2 == iLastIdx) {
			int iNrElements = idx2 - idx1;
			Group newGroup = new Group(iNrElements);

			groups.get(index).setCollapsed(false);
			groups.get(index).setSelectionType(SelectionType.NORMAL);
			groups.get(index).setSize(groups.get(index).getSize() - iNrElements);
			groups.add(index + 1, newGroup);

			return true;
		}

		// 2 new groups
		int iNrElements2 = idx2 - idx1;
		Group newGroup2 = new Group(iNrElements2);
		int iNrElements3 = iLastIdx - idx2;
		Group newGroup3 = new Group(iNrElements3);

		groups.get(index).setCollapsed(false);
		groups.get(index).setSelectionType(SelectionType.NORMAL);
		groups.get(index).setSize(idx1 - iFirstIdx);
		groups.add(index + 1, newGroup2);
		groups.add(index + 2, newGroup3);

		return true;
	}

	/**
	 * Moves the element at the specified src index to the target index. The
	 * element formerly at iSrcIndex is at iTargetIndex after this operation.
	 * The rest of the elements can change the index.
	 *
	 * @param virtualArray
	 *            the virtual array for updating indexes
	 * @param iSrcIndex
	 *            the source index of the element
	 * @param iTargetIndex
	 *            the target index of the element
	 * @return true if operation executed correctly otherwise false
	 */
	public boolean move(VA virtualArray, int srcIndex, int targetIndex) {

		int icurrentIdx = -1;

		if (srcIndex == targetIndex) {
			// nothing to do
			return false;
		} else if (srcIndex < targetIndex) {

			icurrentIdx = srcIndex;
			while (icurrentIdx < targetIndex) {
				interchange(virtualArray, icurrentIdx, icurrentIdx + 1);
				icurrentIdx++;
			}
		} else {

			icurrentIdx = srcIndex;
			while (icurrentIdx > targetIndex) {
				interchange(virtualArray, icurrentIdx - 1, icurrentIdx);
				icurrentIdx--;
			}
		}
		return true;
	}

	@Override
	@SuppressWarnings({ "unchecked" })
	public ConcreteType clone() {
		ConcreteType groupList = this.createInstance();
		// try {
		// groupList = (GroupList) super.clone();
		// }
		// catch (CloneNotSupportedException e) {
		// throw new IllegalStateException("Clone not supportet: " +
		// e.getMessage());
		// }
		groupList.setGroups((ArrayList<Group>) groups.clone());
		return groupList;
	}

	public ArrayList<Group> getGroups() {
		return groups;
	}

	public void setGroups(ArrayList<Group> groups) {
		this.groups = groups;
	}

	public void removeElementOfVA(int indexOfElement) {

		int iOffset = 0;
		int iGroupIdx = 0;
		for (int index = 0; index < groups.size(); index++) {
			iOffset += groups.get(index).getSize();
			if (iOffset > indexOfElement)
				break;
			iGroupIdx++;
		}

		groups.get(iGroupIdx).setSize(groups.get(iGroupIdx).getSize() - 1);
		if (groups.get(iGroupIdx).getSize() == 0)
			groups.remove(iGroupIdx);

	}

	public Group getGroupOfVAIndex(int index) {
		int from = 0;
		int to = 0;
		for (Group group : groups) {
			to += group.getSize();
			if (index >= from && index < to)
				return group;
			from = to;
		}
		return null;

	}

	@Override
	public String toString() {
		return "GroupList: " + groups.toString();
	}

	/**
	 *
	 * Updates the information of the group, such as group index etc.
	 *
	 * FIXME
	 *
	 * @deprecated this should be integrated into the group list. We should not
	 *             be required to call this explicitly
	 */
	@Deprecated
	public void updateGroupInfo() {
		int length = 0;
		int index = 0;
		for (Group group : groups) {
			group.setStartIndex(length);
			group.setGroupIndex(index++);
			length += group.getSize();
		}
	}
}
